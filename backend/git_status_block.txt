app.get('/git/status/:projectId', async (req, res) => {
  let { projectId } = req.params;

  // Remove ws- prefix if present
  if (projectId.startsWith('ws-')) {
    projectId = projectId.substring(3);
  }


  // ===========================================
  // VIBE CODING: CLOUD GIT STATUS
  // ===========================================
  const wsName = projectId.replace(/^ws-/, '').replace(/[^a-z0-9-]/g, '-').toLowerCase().substring(0, 32);

  try {
    await coderService.ensureUser('admin@drape.dev', 'admin');
    const { exec } = require('child_process');
    const { promisify } = require('util');
    const execAsync = promisify(exec);

    console.log(`☁️  Git Status Check in cloud: ${wsName}`);

    // We run a combined script in the cloud to gather all git info at once
    // This is faster than multiple SSH calls
    const script = `
        if [ -d .git ]; then
            echo "IS_GIT:true"
            echo "BRANCH:$(git rev-parse --abbrev-ref HEAD)"
            echo "---LOG---"
            git log --pretty=format:"%H|%h|%s|%an|%ae|%aI" -20
            echo ""
            echo "---STATUS---"
            git status --porcelain
        else
            echo "IS_GIT:false"
        fi
    `.replace(/\n/g, ' '); // simple sanitization

    const { stdout } = await execAsync(`coder ssh ${wsName} -- sh -c '${script}'`, {
      env: { ...process.env, CODER_SESSION_TOKEN: process.env.CODER_SESSION_TOKEN },
      timeout: 10000
    });

    // Parse output
    const output = stdout.toString().trim();
    if (output.includes("IS_GIT:false")) {
      return res.json({ isGitRepo: false });
    }

    const currentBranchMatch = output.match(/BRANCH:(.*)/);
    const currentBranch = currentBranchMatch ? currentBranchMatch[1] : 'main';

    // Parse commits
    const logPart = output.split('---LOG---')[1]?.split('---STATUS---')[0] || '';
    const commits = logPart.trim().split('\n').filter(l => l).map((line, index) => {
      const [hash, shortHash, message, author, authorEmail, date] = line.split('|');
      return {
        hash,
        shortHash,
        message,
        author,
        authorEmail,
        date: new Date(date),
        isHead: index === 0,
        branch: index === 0 ? currentBranch : undefined
      };
    });

    // Parse status
    const statusPart = output.split('---STATUS---')[1] || '';
    let status = { staged: [], modified: [], untracked: [], deleted: [] };

    if (statusPart.trim()) {
      statusPart.trim().split('\n').forEach(line => {
        const code = line.substring(0, 2);
        const file = line.substring(3);
        if (code[0] === 'A' || code[0] === 'M' || code[0] === 'D') status.staged.push(file);
        if (code[1] === 'M') status.modified.push(file);
        if (code === '??') status.untracked.push(file);
        if (code[1] === 'D') status.deleted.push(file);
      });
    }

    // Return mocked branches for now to save complexity, or fetch them too
    const branches = [{ name: currentBranch, isCurrent: true, isRemote: false }];

    res.json({
      isGitRepo: true,
      currentBranch,
      commits,
      branches,
      status
    });

  } catch (error) {
    console.error('❌ Cloud Git Status Error:', error.message);
    res.status(500).json({ error: error.message });
  }

  /*
  const reposDir = path.join(__dirname, 'cloned_repos');
  const repoPath = path.join(reposDir, projectId);

  try {
    // Check if repo exists

    await fs.access(repoPath);

    // Check if it's a git repo
    const gitDir = path.join(repoPath, '.git');
    try {
      await fs.access(gitDir);
    } catch {
      return res.json({ isGitRepo: false });
    }





res.json({
  isGitRepo: true,
  currentBranch,
  commits,
  branches,
  status
});

  } catch (error) {
  console.error('❌ Git status error:', error.message);
  res.json({ isGitRepo: false, error: error.message });
}
});

